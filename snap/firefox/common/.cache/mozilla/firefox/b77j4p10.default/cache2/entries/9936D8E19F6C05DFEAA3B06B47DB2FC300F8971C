if (! window.rsUEF) { window.rsUEF = {}; }

window.rsUEF.client = (() => {

	var

	/**
	 * This is a list of the different content types that this integration can display in the ReadSpeaker panel.
	 * @type {Array}
	 */
	_supportedRoutes = [
		{
			name: 'Course Content (Document)',
			route: '\.peek\.content-manage\.edit\.document',
			apiType: 'content'
		},
		{
			name: 'Course Content (Assignment with offline submission)',
			route: '\.peek\.assessment\.external-overview',
			apiType: 'content'
		},
		{
			name: 'Course Content (List)',
			route: '\.peek\.course\.outline',
			apiType: 'content'
		},
		{
			name: 'Course Content (Test with offline submission)',
			route: '\.peek\.gradebook-item\.assessment',
			apiType: 'content'
		},
		{
			name: 'Course Content (Discussion)',
			route: '\.peek\.discussion\.view\.with-grading',
			apiType: 'discussion'
		}/*, 2022-03-15: Journal entries don't seem to be fully implemented in the REST API yet as the result does not contain any content handler and therefore cannot be handled in the RS backend.
		{
			name: 'Course Content (Journal)',
			route: '\.peek\.journal\.view\.with-participation',
			apiType: 'content'
		}*/

	],

	/**
	 * Placeholder for the auth token.
	 * @type {Object}
	 */
	_token = null,

	_isBannerVisible = null,

	/**
	 * Some sort of enumeration for different types of callbacks. We use an object instead of having to remember the integer value.
	 * @type {Object}
	 */
	_callbacks = {
		listenButtonClicked: 1
	},

	/**
	 * Controls and gives values for 
	 * @type {Object}
	 */
	_Settings = {
		/**
		 *  Contains the object for customer parameters.
		 * @type {Object}
		 */
		config: null,
		/**
		 * Sets the configuration as the input config object, with fallback to default.
		 * @type {Object}
		 */
		setConfig: (params) => {
			params = params || window.vars.getMessageHint().customParams;
			_Settings.config = params;
		},

		/**
		 * Returns the key from the config object.
		 * 
		 * @param {String}
		 * @return {Object}
		 */
		getConfig: (key) => {
			if (!_Settings.config) {
				_Settings.setConfig();
			}
			if (_Settings.config.hasOwnProperty(key)) {
				// Return true/false if we are dealing with a value that should represent true or false.
				if (_Settings.config[key] === '1' || _Settings.config[key] === 'true') return true;
				if (_Settings.config[key] === '0' || _Settings.config[key] === 'false') return false;
				return _Settings.config[key];
			} else {
				return false;
			}
		}

	},

	/**
	 * Controls messages posted between frames on the page.
	 * 
	 * @type {Object}
	 */
	_Message = {
		/**
		 * Will be used to send and receive messages to/from Ultra via a secure MessageChannel.
		 * @type {LoggedMessageChannel}
		 */
		channel: null,
		/**
		 * Fires when a message has been received from another frame.
		 * 
		 * @param  {MessageEvent}  The message event that was received.
		 * @return {Void}
		 */
		received: (e) => {
			
			const isTrusted =
				e.origin === window.__lmsHost || e.origin === window.vars.host;

			if (!isTrusted || !e.data || !e.data.type) {
				console.warn('ReadSpeaker: Untrusted message stopped.');
				return;
			} else {

				switch (e.data.type) {

					case 'integration:hello' :

						// We received an integration ping from Ultra. Now we can start
						// the process by: 
						// 		1. Creating a message channel, and
						// 		2. register a message handler, and last but not least, 
						// 		3. start the authorization process.

						_Message.channel = new LoggedMessageChannel(e.ports[0]);
						_Message.channel.onmessage = _Message.fromUltra;
						_Authorization.authorize();
						break;

				}
			}
		},
		/**
		 * Handles messages that are received from Ultra over the message channel.
		 * 
		 * @param  e  {MessageEvent}  
		 * @return {Void}
		 */
		fromUltra: (e) => {

			switch (e.data.type) {

				case 'authorization:authorize' :

					// Yay! We're authorized with Ultra and can start subscribing to events.
					_Authorization.authorized();

					// We can now insert our JS solution
					_Injection.injectScript();

					break;

				case 'event:event' :

					// We received an event from Ultra. Some of them we handle, others will just
					// disappear into the ether...

					if (e.data.eventType === 'route') {

						// The user navigated, ie changed the "route".

						let route = _Route.identify(e.data.routeName);
						if (route !== null) {
							_Panel.setData(e, route);
							_Panel.rendered(e);
						} else {
							_Panel.clearData();
						}
					} else if (e.data.eventType === 'help:request') {

						// The user clicked on our trigger button in the Help panel.

						// Send this message in order to prevent Bb from opening the default help page.
						_Message.channel.postMessage({
							type: 'help:request:response',
							correlationId: e.data.correlationId
						});

						_Panel.request(e);

					} else if (e.data.eventType === 'portal:new') {

						// A new view, a so called portal was opened...

						if (e.data.selector === 'course.banner.top') {

							// This was the course banner, show our course banner trigger button if we have docReader enabled
							if (_Settings.getConfig('docReader')) {
								var portal_Id = e.data.portalId;
								window.localStorage.setItem('portalId', portal_Id);
							}
						}

					}

					break;

				case 'portal:panel:response' :

					// Ultra replied to our request for a new portal panel.
					// Check that it is what we expected it to be.

					if (e.data.correlationId === _Panel.correlationId) {

						// The correlation ID checks out, so let's render the content.
						_Panel.render(e);
					}
					break;

				case 'portal:callback' :

					// One of the portals triggered a callback that we had added, check which type it was.

					if (e.data.callbackId === _callbacks.listenButtonClicked) {

						// It was a click on our course banner Listen button, open our panel.
						_Panel.request(e);
					}

					break;
			}

		}
	},

	/**
	 * 	This object handles the JS injection and inserts the necessary JavaScript into the page.
	 * 
	 * @type {Object}
	 */
	_Injection = {
		injectScript: (params) => {
			var mh = window.vars.getMessageHint();

			// Construct which items to send to the script
			var
			scriptParams = mh.customParams,
			params = '',
			firstItem = true;

			// If no region is set, set it to default 'na'
			scriptParams['region'] = scriptParams['region'] || 'na';

			for (var key in scriptParams) {
				if (scriptParams.hasOwnProperty(key)) {
					params += (!firstItem ? '&' : '') + key + '=' + scriptParams[key];
					firstItem = false;
				}
			}

			var scriptSrc = 'https://cdn-' + scriptParams['region'] + '.readspeaker.com/script/default/webReaderForEducation/blackboardultra/v1/ReadSpeaker.BlackboardUltra.js?'

			// If we're in debug mode, we load the script from labs
			if (mh.customParams.debug) {
				scriptSrc = 'https://wr-test.readspeaker.team/script/blackboard/ORIG/ReadSpeaker.BlackboardUltra.js?';
			}

			_Message.channel.postMessage({
				type: 'injectjs:inject',
				url: scriptSrc + params
			});
		}
	}

	/**
	 * This object does things when the user has navigated in the Ultra UI.
	 * 
	 * @type {Object}
	 */
	_Route = {

		/**
		 * Identifies what type of route the user has navigated to, and if it's one of the supported ones, returns some information about it.
		 * 
		 * @param  {String} routeName  The routename as given to us by UEF.
		 * @return {Object}            If supported, returns an object with information about the route, if not supported returns null.
		 */
		identify: (routeName) => {

			let currentRoute = null;

			if (typeof routeName === 'string' && routeName.length) {
				for (var i = 0, j = _supportedRoutes.length; i < j; i++) {
					currentRoute = _supportedRoutes[i];

					if (new RegExp(currentRoute.route, 'i').test(routeName)) {
						return currentRoute;
					}
				}
			}

			return null;
		}

	},

	/**
	 * Code that relates to the Ultra Course banner, where we place a trigger button.
	 * @type {Object}
	 */
	_Banner = {
		/**
		 * Renders our trigger button in the Ultra course banner.
		 * 
		 * @param  {String}  portalId  We requested to open a portal, and this is the ID it was assigned.
		 * @return {Void}
		 */
		show: (portalId) => {
			//console.info('[ReadSpeaker] Show banner!');

			// Render our trigger button, in the portal we were assigned.
			// We remove this for now, since we only want to inject the JS with the current solution 
			_Message.channel.postMessage({
				type: 'portal:render',
				portalId: portalId,
				contents: {
					tag: 'div',
					children: [{
						tag: 'button',
						children: [{
							tag: 'img',
							props: {
								src: window.vars.localUrl + '/assets/rs-logo-icon-white.png',
								style: {
									width: 16,
									height: 16,	
									marginRight: '5px'								
								}
							}
						}, {
							tag: 'span',
							children: window.rsUEF.lang.getPhrase('coursebanner.heading')
						}],
						props: {
							onClick: {
								callbackId: _callbacks.listenButtonClicked,
								mode: 'sync'
							},
							style: {
								padding: '10px',
								cursor: 'pointer',
								fontWeight: 'bold'
							}
						},
						title: window.rsUEF.lang.getPhrase('coursebanner.alttext')
					}]
				}
			});
			_isBannerVisible = true;
		},

		hide: (portalId) => {
			_Message.channel.postMessage({
                type: 'portal:render',
                portalId: portalId,
                contents: {
                    tag: 'div',
                    props: {
                        style: {
                            display: 'none' // Hide the banner when it's already visible
                        }
                    }
                }
            });
		    _isBannerVisible = false; // Set visibility to false
		}
	},

	/**
	 * Methods that pertain to localStorage. All communication with our content iframe
	 * goes through localStorage, so we listen to the storage change event, to see if we get
	 * information from the other side.
	 * 
	 * @type {Object}
	 */
	_Storage = {

		/**
		 * Fires when the content iframe wants to communicate with our UEF app.
		 * 
		 * @param  {Event}  e  The storage changed event.
		 * @return {Void}
		 */
		changed: (e) => {

			if (e.key === 'rs-panel-state') {

				if (e.newValue === 'initialized') {
					// The content iframe has rendered. Yay!
					_Panel.rendered();
					
				}
			} else if (e.key === 'rs-content-fragment-request') {
				_Content.requested(JSON.parse(e.newValue));
			}

			// Remove the key, so that we can send it again.
			window.localStorage.removeItem(e.key);
		}

	},

	_Content = {
		requested: (params) => {
			if (params.type) {

				switch (params.type) {

					case 'discussion.replies' :
						_Content.discussion.replies.load(params);
						break;

				}

			} else {
				console.log(window.rsUEF.lang.getPhrase('nocontenttypespecified'));
			}
		},
		discussion: {
			replies: {
				load: (params) => {
					const	mh = window.vars.getMessageHint(),
							endpoint = window.vars.localUrl 
						+ '/ajax.php?action=get_content&api_type=' + _Panel.apiType + '&course_id=' + _Panel.courseId 
						+ '&content_id=' + _Panel.contentId 
						+ '&token=' + JSON.stringify(window.vars.getToken())
						+ '&authcode=' + window.vars.authcode
						+ '&last_refresh=' + window.vars.lastRefresh
						+ '&host=' + window.vars.host
						+ '&parent_id=' + params.parentId
						+ '&lang=' + mh.customParams.lang;
					_Panel.content.load(endpoint, _Content.discussion.replies.loaded, 'GET');					
				},
				loaded: (e) => {
					const json = JSON.parse(e.target.response);

					window.localStorage.setItem('rs-content-fragment', JSON.stringify({
						title: json.data[0].title,
						body: json.data[0].body,
						type: 'discussion.replies',
						parentId: json.data[0].parent_id
					}));

					if (json.token_refreshed) {

						// The auth token was refreshed on the server, update the client-side 
						// settings to reflect this.
						_Authorization.token.refreshed(json.token, json.last_refresh);
					}
				}
			}
		}
	},

	/**
	 * The panel is our content iframe that opens inside Ultra. It's the area where we can render content
	 * and where the user can interact with our services.
	 * 
	 * @type {Object}
	 */
	_Panel = {
		correlationId: 'rs-panel-1',
		courseId: null,
		contentId: null,
		apiType: 'content',

		/**
		 * Sets some information about the page that the user is currently on. This information will be used
		 * once the user triggers our panel. We won't have access to the information at that time, so we
		 * store it locally.
		 * 
		 * @param  {Event}   e      The MessageEvent that triggered this action.
		 * @param  {String}  route  The Ultra path to where the user navigated.
		 * 
		 * @return {Void}
		 */
		setData: (e, route) => {
			_Panel.courseId = e.data.routeData.courseId;
			_Panel.contentId = e.data.routeData.id || e.data.routeData.contentId;
			_Panel.apiType = route.apiType;
		},

		/**
		 * Clears the page information. This is done, for instance, when we're on a page that has a
		 * type of content that we don't support.
		 * @return {Void}
		 */
		clearData: () => {
			_Panel.courseId = null;
			_Panel.contentId = null;
		},

		/**
		 * Sends a request to Ultra to open our ReadSpeaker panel.
		 * 
		 * @param  {Event} e The event that triggered this action.
		 * @return {Void}
		 */
		request: (e) => {

			// This is not a page type that we support, display a message.
			if (_Panel.courseId === null) {
				_Modal.request('ReadSpeaker', window.rsUEF.lang.getPhrase('unsupportedpagetype'));
				return;
			}

			// Let the request go!!!
			_Message.channel.postMessage({
				type: 'portal:panel',
				correlationId: _Panel.correlationId,
				panelType: 'small',
				panelTitle: window.rsUEF.lang.getPhrase('rspanel.heading'),
				attributes: {}
			});

		},

		/**
		 * Ultra approved our request to open a new panel, so this method renders its content. 
		 * Or, at least start the rendering process.
		 * 
		 * @param  {MessageEvent} e The Event that triggered this action.
		 * @return {Void}
		 */
		render: (e) => {
			const 	panelId = e.data.portalId;

			// Fetch the content and ask Ultra to render it in our panel. 
			// The data is fetched from our integration website and placed in our iframe.
			_Message.channel.postMessage({
				type: 'portal:render',
				portalId: panelId,
				contents: {
					tag: 'iframe',
					props: {
						style: {
							display: 'flex',
							height: '100%',
							width: '100%',
							flexDirection: 'column',
							alignitems: 'stretch',
							justifyContent: 'stretch'
						},
						className: 'rs-read-panel',
						src: window.vars.localUrl + '/web/index.php?cid=' + _Settings.getConfig('customerid') + '&lang=' + _Settings.getConfig('lang') + '&region=' + (_Settings.getConfig('region') || 'eu')
					}
				}
			});
		},

		/**
		 * Our iframe has been rendered, now load the actual content into it. This is done via an AJAX request
		 * that queries the Learn REST API.
		 * 
		 * @param  {Event} e The event that triggered this action.
		 * @return {Void}
		 */
		rendered: (e) => {

			const 	token = window.vars.getToken(),
					endpoint = window.vars.localUrl 
						+ '/ajax.php?action=get_content&api_type=' + _Panel.apiType + '&course_id=' + _Panel.courseId 
						+ '&content_id=' + _Panel.contentId 
						+ '&token=' + JSON.stringify(token)
						+ '&authcode=' + window.vars.authcode
						+ '&last_refresh=' + window.vars.lastRefresh
						+ '&host=' + window.vars.host
						+ '&lang=' + _Settings.getConfig('lang');

			// Ping the iframe through localStorage. Set customer ID and language. 
			// This needs to be done asynchronously, hence the setTimeout.
			setTimeout(() => {

				// Set some configuration data
				window.localStorage.setItem('rs-config', JSON.stringify({
					customerid: _Settings.getConfig('customerid'),
					lang: _Settings.getConfig('lang')
				}));


			}, 200);

			// Get the content of the page that the user is on.
			_Panel.content.load(endpoint, _Panel.content.loaded, 'GET');

		},
		/**
		 * Deals with the content in our iframe panel.
		 * @type {Object}
		 */
		content: {

			/**
			 * Starts the content loading process.
			 * 
			 * @param  {String}   endpoint The endporint of the backend component where the loading happens. Normally ajax.php.
			 * @param  {Function} cb       Function to call when loading has finished.
			 * @param  {string}   method   The HTTP method to use for the AJAX call.
			 * @return {Void}
			 */
			load: (endpoint, cb, method) => {

				method = method || 'GET';
				const xhr = new XMLHttpRequest();
				xhr.addEventListener('load', cb, false);
				xhr.open(method, endpoint);
				xhr.send();
			},

			/**
			 * Takes care of the page content after it has been loaded via AJAX.
			 * Note that the communication with our iframe is done via localStorage
			 * so this method does not alter the DOM, but merely stores the content
			 * for the iframe to take care of.
			 * 
			 * @param  {LoadEvent} e The event that triggered this action.
			 * @return {Void}
			 */
			loaded: function(e) {
				//console.log('ReadSpeaker - Server responded:', this.response);
				const json = JSON.parse(this.response);

				const tempDiv = document.createElement('div');
			    tempDiv.innerHTML = json.data[0].body;
			
			    const allLinks = tempDiv.querySelectorAll('a[data-bbtype], a[data-bbfile]');
			
			    const documentSelector = Array.from(allLinks).filter(link => {
				    // Check if data-bbtype exists
				    const hasBbtype = link.hasAttribute('data-bbtype');
				    const bbtypeValue = hasBbtype ? link.getAttribute('data-bbtype') : null;
				
				    // Include the link if:
				    // 1. data-bbtype is "attachment"
				    // 2. or data-bbfile exists and data-bbtype does not exist
				    return (hasBbtype && bbtypeValue === "attachment") || (!hasBbtype && link.hasAttribute('data-bbfile'));
				});
			    
			    if (documentSelector.length > 0) {
			        const portalId = window.localStorage.getItem('portalId');
			        if (portalId) {
			            _Banner.show(portalId);  // Show the banner if matches found
			        }
			    } else {
			    	if (_isBannerVisible){
				        const portalId = window.localStorage.getItem('portalId'); // Retrieve the portalId to hide the banner if no matches found
							_Banner.hide(portalId);
					}
			    }

				// Store the fetched data in localStorage. Our iframe is listening to the
				// storage.change event and will take care of the content.
				window.localStorage.setItem('rs-content', JSON.stringify({
					title: json.data[0].title,
					body: json.data[0].body
				}));

				if (json.token_refreshed) {

					// The auth token was refreshed on the server, update the client-side 
					// settings to reflect this.
					_Authorization.token.refreshed(json.token, json.last_refresh);
				}

			}			
		}

	},

	/**
	 * We sometimes need to display messages to the user via a modal dialog.
	 * This object handles all interaction with the modal.
	 * 
	 * @type {Object}
	 */
	_Modal = {
		/**
		 * The internal identifier of the modal dialog we will be using.
		 * @type {String}
		 */
		modalId: 'rs-modal-1',

		/**
		 * Asks Ultra to open a modal dialog for us.
		 * @param  {String} title The modal dialog.
		 * @param  {String} msg   The body text of the dialog.
		 * @return {Void}
		 */
		request: (title, msg) => {

			_Message.channel.postMessage({
				type: 'portal:modal',
				modalId: _Modal.modalId,
				contents: {
					tag: 'Modal',
					props: {
						width: 'medium'
					},
					children: [
						{
							tag: 'ModalHeader',
							props: {
								title: title
							}
						},
						{
							tag: 'ModalBody',
							children: [{
								tag: 'span',
								children: msg
							}]
						},
						{
							tag: 'ModalFooter',
							children: []
						}
					]
				}
			});
		}
	},

	/**
	 * Takes care of things that concern our ReadSpeaker link in Ultra's help menu.
	 * @type {Object}
	 */
	_Trigger = {

		/**
		 * Asks Ultra to render our ReadSpeaker link in the help menu.
		 * @return {Void}
		 */
		render: () => {
			_Message.channel.postMessage({
				type: 'help:register',
				id: _Panel.correlationId,
				displayName: window.rsUEF.lang.getPhrase('helplink.label'),
				iconUrl: window.vars.localUrl + '/assets/rs-logo-icon.png',
				providerType: 'auxiliary',

			});
		}

	},

	/**
	 * Manages everything that has to do with authorizing with Ultra.
	 * @type {Object}
	 */
	_Authorization = {

		/**
		 * Initiates an authorization request to Ultra, using the access token we received
		 * in authcode.php.
		 * @return {Void}
		 */
		authorize: () => {

			_Message.channel.postMessage({
				type: 'authorization:authorize',
				token: _token.access_token
			});
		},

		/**
		 * We have been authorized successfully. Start subscribing to some Ultra events.
		 * @return {[type]} [description]
		 */
		authorized: () => {

			_Message.channel.postMessage({
				type: 'event:subscribe',
				subscriptions: ['click','route','portal:new','portal:remove'],
			});

			// Render our ReadSpeaker link in Ultra's help menu.
			// Remove this for now since we only want to inject the JS
			/*_Trigger.render();*/
		},

		/**
		 * Methods that pertain to the auth token.
		 * @type {Object}
		 */
		token: {

			/**
			 * Update the local version of the auth token, when it has been updated on the server.
			 * @param  {Object}  newToken     The new auth token.
			 * @param  {Int}     lastRefresh  Date time for when the token was refreshed. Expressed as UNIX timestamp (seconds).
			 * @return {Void}
			 */
			refreshed: (newToken, lastRefresh) => {
				window.vars.setToken(newToken);
				window.vars.lastRefresh = lastRefresh;				
			}
		}

	},

	/**
	 * Is executed as soon as Ultra has loaded our integration in an iframe.
	 * This is the starting point for this entire application.
	 * @return {Void}
	 */
	_init = () => {
		
		_token = window.vars.getToken();

		_isBannerVisible = false;

		// Initialize the language manager.
		window.rsUEF.lang.init(window.vars.phraseData);

		// Start listening for messages.
		window.addEventListener('message', _Message.received, false);

		// Clear localStorage from the items we will be using, in order to make sure
		// storage events trigger.
		window.localStorage.clear();

		// And listen for changes to localStorage
		window.addEventListener('storage', _Storage.changed, false);

		// Initiate handshaking with Ultra.
		window.parent.postMessage(
			{ type: 'integration:hello' },
			window.vars.host + '/*'
		);
	};

	return {
		init: _init,
		getConfig: _Settings.getConfig
	};

})();

window.addEventListener('load', window.rsUEF.client.init, false);

/**
 * A MessageChannel-compatible API, but with console logging.
 */
class LoggedMessageChannel {

	onmessage = () => { 
		console.log('test');
	};
  
	constructor(messageChannel) {
		this.messageChannel = messageChannel;
		this.messageChannel.onmessage = this.onMessage;
	};
  
	onMessage = (evt) => {
		// Check if we should output in console
		if (window.rsUEF.client.getConfig('debug')) {
			console.log(`[ReadSpeaker] From Ultra:`, evt.data);
		}
		this.onmessage(evt);
	};
  
	postMessage = (msg) => {
		if (window.rsUEF.client.getConfig('debug')) {
			console.log(`[ReadSpeaker] To Ultra`, msg);
		}
		this.messageChannel.postMessage(msg);
	};

}Y‹%yÿ      g¥B#g¥B$G×tg¬,M   b    O^partitionKey=%28https%2Cblackboard.com%29,:https://lti.readspeaker.com/bbultra/v1/js/tool.min.js necko:classified 1 strongly-framed 1 security-info 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 request-method GET response-head HTTP/1.1 200 OK
Date: Thu, 06 Feb 2025 23:13:40 GMT
Server: Apache
Last-Modified: Mon, 16 Dec 2024 12:26:35 GMT
ETag: "5bdf-629624a9cdeb0"
Accept-Ranges: bytes
Content-Length: 23519
Content-Type: application/javascript
 original-response-headers Date: Thu, 06 Feb 2025 23:13:40 GMT
Server: Apache
Last-Modified: Mon, 16 Dec 2024 12:26:35 GMT
ETag: "5bdf-629624a9cdeb0"
Accept-Ranges: bytes
Content-Length: 23519
Connection: close
Content-Type: application/javascript
 ctid 2 uncompressed-len 0 net-response-time-onstart 741 net-response-time-onstop 877   [ß